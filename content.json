{"meta":{"title":"My World","subtitle":"Talk is cheap,show me your code!","description":null,"author":"张昊","url":"http://zhanghao.studio"},"pages":[{"title":"分类~","date":"2017-04-12T17:31:16.000Z","updated":"2017-04-12T17:34:12.000Z","comments":false,"path":"categories/index.html","permalink":"http://zhanghao.studio/categories/index.html","excerpt":"","text":""},{"title":"标签~","date":"2017-03-23T16:18:33.000Z","updated":"2017-04-12T17:33:25.000Z","comments":false,"path":"tags/index.html","permalink":"http://zhanghao.studio/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"java注解","slug":"java注解","date":"2017-07-16T09:29:36.000Z","updated":"2017-07-16T16:26:59.000Z","comments":true,"path":"java注解.html","link":"","permalink":"http://zhanghao.studio/java注解.html","excerpt":"前言初学 Java 时，注解这部分知识是匆匆略过的，后来开发 Android 过程中遇到 butterknife 等跟注解有关的代码，也只是按照 API 调用，没有深入研究。前几天跟 web 端同事联调时，发现他们代码中用到注解的地方挺多，方法体上方加一行简短的代码，就能实现复杂的业务逻辑。所以今天认真研究一下注解的用法和特性，弥补知识漏洞。","text":"前言初学 Java 时，注解这部分知识是匆匆略过的，后来开发 Android 过程中遇到 butterknife 等跟注解有关的代码，也只是按照 API 调用，没有深入研究。前几天跟 web 端同事联调时，发现他们代码中用到注解的地方挺多，方法体上方加一行简短的代码，就能实现复杂的业务逻辑。所以今天认真研究一下注解的用法和特性，弥补知识漏洞。 Java 中的注解Annotation 是 Java 1.5 中引入的，用来描述 Java 代码的元数据。那什么是元数据呢？下面是wiki的解释： 元资料（Metadata），又称元数据、诠释资料、中介资料、中继资料、后设资料等，为描述其他资料资讯的资料[1]。有三种不同类型的元资料，分别是记叙性元资料、结构性元资料和管理性元资料[2]。 好吧，看了跟没看一样。我个人觉得 annotation 从形式上看类似于注释，写在某个类或方法上面，有解释说明某段代码的作用，但它比注释牛比，可以实现一些功能逻辑，影响代码的运行。 注解的分类 内置注解 Java 提供了三个内置注解，如下所示，都是最常见的。 @Deprecated ：表示java不赞成使用这些被描述的对象 @Override ：用来修饰对父类进行重写的方法。如果父类中的方法名称或参数发生改变时，如果子类没有做相应的调整 编译器便会报错 @SuppressWarnings ：使编译器忽略掉编译器警告，比如使用了 Deprecated 的类或方法 元注解 元注解就是描述注解的注解。我们可以通过元注解来控制自定义注解的行为。 1234567891011121314151617181920212223242526作者：蛋西链接：http://www.jianshu.com/p/01fa86f24c4a來源：简书// 标志将此注解包含至javadoc中@Documented // 定义注解保存级别// 1.SOURCE 源代码注解，被编译器丢弃// 2.CLASS 类注解，被编译器记录在class文件中，运行时被VM丢弃，在编译时使用，属于默认配置// 3.RUNTIME 被编译器记录在class文件中，运行时可用，被VM保留，所以可以在运行时搭配反射使用@Retention(RetentionPolicy.RUNTIME)// 定义注解适用的目标// 1.TYPE Class类，接口(包括注解类型或者enum类型)// 2.FIELD 属性(包括enum实例)// 3.METHOD 方法// 4.PARAMETER 方法参数// 5.CONSTRUCTOR 类构造器// 6.LOCAL_VARIABLE 本地变量// 7.ANNOTATION_TYPE 注解类型// 8.PACKAGE 包@Target(ElementType.METHOD)//想让一个类和它的子类都包含某个注解，就可以使用@Inherited来修饰这个注解。@Inherited 自定义注解 我看到的公司 web 端代码就是自定义注解，创建方法类似接口，可以通过default关键字为某个元素设置默认值。 123456@interface MyAnnotation &#123; String value() default \"xxx\"; String name(); int age(); String[] newNames();&#125; 注解中的每个元素定义类似于接口中的方法定义。每个元素定义包含一个数据类型和名称，注解元素的数据类型可以是 java 基本数据类型、String、数组，但不能是复杂对象类型。 下面这段代码演示了如何使用注解: 123456789@MyAnnotation( value=\"123\"（value有默认值了，这里可以不指定）, name=\"Jakob\", age=37, newNames=&#123;\"Jenkov\", \"Peterson\"&#125;)public class MyClass &#123;&#125; 我们需要为所有的注解元素设置值，一个都不能少，但有默认值的元素，我们可以不设值。 通过反射获取注解中的信息​ 对于运行时注解，我们可以通过反射机制获得注解信息。 获取类的注解信息 123456@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface MyAnnotation &#123; public String name(); public String value();&#125; 1234@MyAnnotation(name = \"hello name\",value = \"hello value\")public class MyClass &#123;&#125; 12345678public class TestAnnotation &#123; public static void main(String[] args) &#123; //通过反射获得MyClass的注解信息 MyAnnotation myAnnotation=MyClass.class.getAnnotation(MyAnnotation.class); System.out.println(myAnnotation.name()); System.out.println(myAnnotation.value()); &#125;&#125; 获取方法的注解信息 12345678910111213141516public class TestAnnotation &#123; public static void main(String[] args) &#123; Method method = null; try &#123; method = MyClassB.class.getMethod(\"method\"); Annotation annotation = method.getAnnotation(MyAnnotation.class); if (annotation !=null) &#123; MyAnnotation myAnnotation = (MyAnnotation) annotation; System.out.println(\"name: \" + myAnnotation.name()); System.out.println(\"value: \" + myAnnotation.value()); &#125; &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 获取参数的注解信息 1234567891011121314151617Method method = ... //obtain method objectAnnotation[][] parameterAnnotations = method.getParameterAnnotations();Class[] parameterTypes = method.getParameterTypes();int i=0;for(Annotation[] annotations : parameterAnnotations)&#123; Class parameterType = parameterTypes[i++]; for(Annotation annotation : annotations)&#123; if(annotation instanceof MyAnnotation)&#123; MyAnnotation myAnnotation = (MyAnnotation) annotation; System.out.println(\"param: \" + parameterType.getName()); System.out.println(\"name : \" + myAnnotation.name()); System.out.println(\"value: \" + myAnnotation.value()); &#125; &#125;&#125; 获取字段的注解信息 12345678Field field = MyClassB.class.getField(\"field\");Annotation annotation = field.getAnnotation(MyAnnotation.class);if(annotation instanceof MyAnnotation)&#123; MyAnnotation myAnnotation = (MyAnnotation) annotation; System.out.println(\"name: \" + myAnnotation.name()); System.out.println(\"value: \" + myAnnotation.value());&#125; Android 中的注解关于 Android 中常用的注解，技术小黑屋有一篇文章介绍的很详细了，传送门，我就不写了。 以上内容借鉴了多篇文章，十分感谢： Java注解详解 详解Java中的注解 java annotation 详解","categories":[{"name":"java","slug":"java","permalink":"http://zhanghao.studio/categories/java/"}],"tags":[{"name":"java&android","slug":"java-android","permalink":"http://zhanghao.studio/tags/java-android/"}]},{"title":"Handler不正确使用可能导致内存泄漏","slug":"Handler不正确使用可能导致内存泄漏","date":"2017-04-12T09:43:12.000Z","updated":"2017-04-12T17:35:28.000Z","comments":true,"path":"Handler不正确使用可能导致内存泄漏.html","link":"","permalink":"http://zhanghao.studio/Handler不正确使用可能导致内存泄漏.html","excerpt":"","text":"","categories":[{"name":"android","slug":"android","permalink":"http://zhanghao.studio/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://zhanghao.studio/tags/android/"}]},{"title":"mac下管理多个ssh秘钥对","slug":"mac-os生成多个ssh秘钥对","date":"2017-04-12T03:06:55.000Z","updated":"2017-04-12T17:38:06.000Z","comments":true,"path":"mac-os生成多个ssh秘钥对.html","link":"","permalink":"http://zhanghao.studio/mac-os生成多个ssh秘钥对.html","excerpt":"一、日常废话昨晚看到一篇提升博客访问速度的文章，其中一点是配置多线路解析，国内路线走国内平台，国外线路走 GitHub Pages。其中，作者提到了国内的代码托管平台 Coding，该平台免费提供静态资源托管，所以我们以前利用 hexo搭建的 GitHub Pages 博客也可以轻松迁移过来。具体步骤我写在另一篇博客中，这里不多讲了。","text":"一、日常废话昨晚看到一篇提升博客访问速度的文章，其中一点是配置多线路解析，国内路线走国内平台，国外线路走 GitHub Pages。其中，作者提到了国内的代码托管平台 Coding，该平台免费提供静态资源托管，所以我们以前利用 hexo搭建的 GitHub Pages 博客也可以轻松迁移过来。具体步骤我写在另一篇博客中，这里不多讲了。 二、遇到的问题及解决办法1.问题场景 公司项目托管在 GitLab,个人项目托管在 GitHub 和 Coding，用到三对 ssh 秘钥， Coding 与 GitHub 一样，需要将使用者的公钥上传到服务器以保证安全传输。所以我用下面的命令生成了 Coding平台专用的秘钥对，至于它的原理，另找时间研究吧。 ssh-keygen -t rsa -C &quot;username@email.com&quot; 换mac后我先 clone 的公司的项目，当时生成的秘钥文件是 id_rsa，对应于 GitLab。这次为 Coding 生成的秘钥不能再用默认命名以免覆盖，另取名 coding_key。问题就出在这里，我把 coding_key.pub 中的公钥上传到Coding后，用以下命令测试还是 Permission denied。 ssh -T git@git.coding.net 2.问题的原因参考这里。 每次连接远程A服务器时，本机的ssh客户端默认发送id_rsa（ssh-keygen生成秘钥对时的默认命名）私钥到A服务端进行验证，如果本机只有这一个秘钥对且生成时没有更改默认命名，那自然不会有问题。但如果本机还与B通信，就需要生成另一对秘钥，上传公钥到B。连接B服务器时，ssh客户端发送的仍然是id_rsa,而与B服务器存储的公钥对应不上，自然就报错了。 我想要的是，不同的ssh秘钥对共存且互不干扰，连接 Server 时自动选择对应私钥。 3.解决方案： https://segmentfault.com/q/1010000000835302 https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/ https://my.oschina.net/stefanzhlg/blog/529403 4.我的做法： 上面提到的解决办法，都是先用ssh-add ~/.ssh/xxx将私钥添加到ssh-agent,然后再编写config文件。我实践了一下，发现在mac系统中，使用 ssh-add 添加和编写 config 文件这两步，只要有一步做到就可以满足需求。不知道window 下是不是必须同时实现才可以。","categories":[{"name":"information security","slug":"information-security","permalink":"http://zhanghao.studio/categories/information-security/"}],"tags":[{"name":"ssh","slug":"ssh","permalink":"http://zhanghao.studio/tags/ssh/"}]},{"title":"优化Github Pages访问速度,去除Coding Pages的广告页","slug":"提升博客的访问速度","date":"2017-04-11T16:21:22.000Z","updated":"2017-06-04T17:08:04.000Z","comments":true,"path":"提升博客的访问速度.html","link":"","permalink":"http://zhanghao.studio/提升博客的访问速度.html","excerpt":"Updated at 2017-06-05：前几天访问博客才发现，Coding 给每个绑定了自定义域名的站都加了一个广告页，等5s后才跳转到主页，想去掉也可以，199元飞升黄金段位即可，唉，白银选手都是辣鸡啊。这真是太恶心了，咱们这小站本来就人迹罕至，再加一5s施法前摇，GGWP。政策一出，群情激愤，于是官方针对我等穷sir，推出 “ Hosted by Coding Pages “免广告服务，就是在你的主页某个位置加上这个超链接文本或图片，审核通过既可去除。 文字版需要添加的代码如下： 1&lt;p&gt;Hosted by &lt;a href=\"https://pages.coding.me\" style=\"font-weight: bold\"&gt;Coding Pages&lt;/a&gt;&lt;/p&gt; 我用的是 NEXT 主题，去修改它的源码， /Users/……/……/themes/next/layout/_partials/footer.swig 1234567891011121314151617181920&lt;div class=\"copyright\" &gt; &#123;% set current = date(Date.now(), \"YYYY\") %&#125; &amp;copy; &#123;% if theme.since and theme.since != current %&#125; &#123;&#123; theme.since &#125;&#125; - &#123;% endif %&#125; &lt;span itemprop=\"copyrightYear\"&gt;&#123;&#123; current &#125;&#125;&lt;/span&gt; &lt;span class=\"with-love\"&gt; &lt;i class=\"fa fa-&#123;&#123; theme.authoricon &#125;&#125;\"&gt;&lt;/i&gt; &lt;/span&gt; &lt;span class=\"author\" itemprop=\"copyrightHolder\"&gt;&#123;&#123; config.author &#125;&#125;&lt;/span&gt;&lt;/div&gt;&#123;% if theme.copyright %&#125;&lt;div class=\"powered-by\"&gt; &#123;&#123; __('footer.powered', '&lt;a class=\"theme-link\" href=\"https://hexo.io\"&gt;Hexo&lt;/a&gt;') &#125;&#125;&lt;/div&gt;&lt;div class=\"theme-info\"&gt; &#123;&#123; __('footer.codingPages') &#125;&#125; &lt;a href=\"https://pages.coding.me\" style=\"font-weight: bold\"&gt;Coding Pages&lt;/a&gt;&lt;/div&gt;&#123;% endif %&#125; 修改了最后一段 div 代码，其中footer.codingPages 是我定义的一个常量 “Hosted by” ，这样就改为我的博客底部的样式了。 日常废话GitHub 是程序猿必备神器，通过它不仅能找到各种开源代码，还能快速搭建个人博客，具体教程可以看这 传送门。幸运的是，我们天朝子民访问 GitHub 还不受GFW限制，但毕竟它的老家在国外，访问速度自然有些拙计。如何提升 GitHub 博客的访问速度呢，一番搜索，学到几发新姿势。","text":"Updated at 2017-06-05：前几天访问博客才发现，Coding 给每个绑定了自定义域名的站都加了一个广告页，等5s后才跳转到主页，想去掉也可以，199元飞升黄金段位即可，唉，白银选手都是辣鸡啊。这真是太恶心了，咱们这小站本来就人迹罕至，再加一5s施法前摇，GGWP。政策一出，群情激愤，于是官方针对我等穷sir，推出 “ Hosted by Coding Pages “免广告服务，就是在你的主页某个位置加上这个超链接文本或图片，审核通过既可去除。 文字版需要添加的代码如下： 1&lt;p&gt;Hosted by &lt;a href=\"https://pages.coding.me\" style=\"font-weight: bold\"&gt;Coding Pages&lt;/a&gt;&lt;/p&gt; 我用的是 NEXT 主题，去修改它的源码， /Users/……/……/themes/next/layout/_partials/footer.swig 1234567891011121314151617181920&lt;div class=\"copyright\" &gt; &#123;% set current = date(Date.now(), \"YYYY\") %&#125; &amp;copy; &#123;% if theme.since and theme.since != current %&#125; &#123;&#123; theme.since &#125;&#125; - &#123;% endif %&#125; &lt;span itemprop=\"copyrightYear\"&gt;&#123;&#123; current &#125;&#125;&lt;/span&gt; &lt;span class=\"with-love\"&gt; &lt;i class=\"fa fa-&#123;&#123; theme.authoricon &#125;&#125;\"&gt;&lt;/i&gt; &lt;/span&gt; &lt;span class=\"author\" itemprop=\"copyrightHolder\"&gt;&#123;&#123; config.author &#125;&#125;&lt;/span&gt;&lt;/div&gt;&#123;% if theme.copyright %&#125;&lt;div class=\"powered-by\"&gt; &#123;&#123; __('footer.powered', '&lt;a class=\"theme-link\" href=\"https://hexo.io\"&gt;Hexo&lt;/a&gt;') &#125;&#125;&lt;/div&gt;&lt;div class=\"theme-info\"&gt; &#123;&#123; __('footer.codingPages') &#125;&#125; &lt;a href=\"https://pages.coding.me\" style=\"font-weight: bold\"&gt;Coding Pages&lt;/a&gt;&lt;/div&gt;&#123;% endif %&#125; 修改了最后一段 div 代码，其中footer.codingPages 是我定义的一个常量 “Hosted by” ，这样就改为我的博客底部的样式了。 日常废话GitHub 是程序猿必备神器，通过它不仅能找到各种开源代码，还能快速搭建个人博客，具体教程可以看这 传送门。幸运的是，我们天朝子民访问 GitHub 还不受GFW限制，但毕竟它的老家在国外，访问速度自然有些拙计。如何提升 GitHub 博客的访问速度呢，一番搜索，学到几发新姿势。 各种姿势 迁移到国内平台 将博客部署到国产代码托管平台，我用的是 Coding。实现步骤跟 GitHub 类似，可以参考 官方教程。 我在添加新的ssh公钥到 Coding 时，遇到了问题，请看 mac下管理多个ssh秘钥对。将代码部署到 Coding 上后，我们得到了一个新的域名，xxx.coding.me，修改一下博客根目录下的配置文件 _config.yml，在 deploy 项下添加 Coding对应的 repo，这样每次执行 hexo d 命令之后，博客内容就会分别部署到 GitHub 和 Coding 了。 绑定一个域名，实现双线访问 如上文所说，迁移到国内平台后，我们又得到一个域名。但是对于同一个博客来说，没有必要，也不利于传播。所以我在万网上买了个域名，即 zhanghao.studio，通过设置域名解析，实现一个域名，双线访问。 首先设置域名解析，下图是万网的域名管理界面： 点击解析后进到编辑界面，万网的记录线路类型有很多，关于每种类型的介绍如下图： 我用到的只有 CNAME 和 A 类型两种，前者的记录值是某一域名，后者记录值是 ip 地址。主机记录填www，会将 zhanghao.studio解析成www.zhanghao.studio；不填则显示为@，直接解析成zhanghao.studio。解析线路有很多，国内访问设置为默认，国外访问设置为海外。记录值是 GitHub 和 Coding 提供的域名，如下图。 到这一步，我们完成了一半的设置，剩下一半的是去 GitHub 和 Coding 绑定你买的域名。 Coding： 进到你托管博客代码的仓库，再进入 Pages 服务，即可看到如上所示界面。Coding 可以绑定5个自定义域名，而 GitHub只能绑定1个。 GitHub： 绑定 GitHub 时需要注意，如果你想像我一样绑定顶级域名 xxx.com，而不加前缀 www，那么必须用 A 记录类型的，详情看 GitHub 官方教程。 至此，我们便实现了博客的双线访问，国内访问走 Coding Pages，国外走GitHub Pages。 利用 CDN 内容分发网络（Content delivery network或Content distribution network，缩写：CDN）是指一种通过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。 对于 CDN ，我仅仅只是了解了一下，就不多讲了。优化思路来自 Next 主题的官方文档 进阶设定。","categories":[{"name":"hexo","slug":"hexo","permalink":"http://zhanghao.studio/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://zhanghao.studio/tags/hexo/"}]},{"title":"Mac常用快捷键和Android+Rn开发环境搭建","slug":"换mac啦","date":"2017-03-21T14:23:28.000Z","updated":"2017-06-04T16:42:27.000Z","comments":true,"path":"换mac啦.html","link":"","permalink":"http://zhanghao.studio/换mac啦.html","excerpt":"一、写在前面的废话 经历一周的纠结，我最终入手了MBP 840。无任何颗粒感的视网膜屏，散发着凉意的金属外壳，象征逼格的信仰灯，真是一件精致的艺术品。敲惯了红轴和茶轴，再体验薄膜键盘也别有一番滋味。我想，我终于理解那些推荐MBP的人了。","text":"一、写在前面的废话 经历一周的纠结，我最终入手了MBP 840。无任何颗粒感的视网膜屏，散发着凉意的金属外壳，象征逼格的信仰灯，真是一件精致的艺术品。敲惯了红轴和茶轴，再体验薄膜键盘也别有一番滋味。我想，我终于理解那些推荐MBP的人了。 二、一些常用快捷键暂时把常用的列举一下，以后再慢慢补充吧。 command + shift + 3/4 截屏/截图 command + m 最小化窗口 command + h 隐藏窗口 command + q 关闭当前程序 command + r 刷新 command + t/w 新建一个选项卡/关闭当前选项卡 command + shift + . 显示隐藏文件夹和文件 command + shift + g 前往指定文件夹 上面是我这几天用的最多的，在知乎上看到一张图，基本上涵盖了最常用的吧： 三、开发环境的搭建 公司项目用的 Android 原生和 React Native混合开发的模式，所以需要搭建 Android 环境和 RN 环境。 Google 了一下，发现苹果有个软件包管理工具 Homebrew 很好用，装上试试 Homebrew是Mac OSX上的软件包管理工具，能在Mac中方便的安装软件或者卸载软件，相当于linux下的apt-get、yum神器；Homebre可以在Mac上安装一些OS X没有的UNIX工具，Homebrew将这些工具统统安装到了 /usr/local/Cellar 目录中，并在 /usr/local/bin 中创建符号链接。 安装很简单，一行指令即可，虽然不懂啥意思… 1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; HomeBrew常用指令 brew search xxx 搜索软件 brew install xxx 安装 brew cask install xxx 安装软件 与上面的区别我不懂，知乎上有两个回答供参考传送门 brew uninstall xxx 卸载 brew list 显示已经安装的软件 我手上这台机器是 os x 10.12.3的，没有自带 Java，所以我们需要手动安装。我们可以去 oracle 官网下载 jdk for mac，也可以用上面提到的 brew cask install java 来进行安装。我没有配置 java 的环境变量，似乎也能用 java -version，神奇。 android studio 直接下载 .dmg 文件即可，它自动设置了 java 的路径， sdk可以通过studio下载,或者找个国内镜像网站下好后放到 sdk 目录下。 ps: 要想在终端下使用 ADB 命令，还得配置sdk的环境变量，参考传送门 进入终端，在用户目录下，输入命令。该命令的作用是如果不存在.bash_profile文件，则创建该文件。 touch .bash_profile 再输入命令，该命令的作用是用文本编辑器TextEdit打开.bash_profile文件 open -e .bash_profile 在编辑器中加入以下路径 export PATH=${PATH}:/Users/xxx(你的sdk路径)/sdk/platform-tools export PATH=${PATH}:/Users/xxx(你的sdk路径)/sdk/tools 保存退出，重启终端，检验是否设置成功 adb version RN 环境搭建，可参考传送门。我简单说下步骤： 安装 node.js ,直接brew install node走你。 安装后，给 npm 设置镜像（GFW你懂得） npm config set registry https://registry.npm.taobao.org --global npm config set disturl https://npm.taobao.org/dist --global 安装 react native 命令行工具 npm install -g react-native-cli 四、终端的 bogon 今晚回家打开终端后，发现终端名称变成了 bogon, what?这他么是啥，搜了一下，找到个解决方案传送门。我用的第一种方法，scutil --set HostName new_hostname ，亲测可行。","categories":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"http://zhanghao.studio/categories/杂七杂八/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://zhanghao.studio/tags/Mac/"}]},{"title":"ARGB与RGBA","slug":"ARGB与RGBA","date":"2017-03-01T14:40:39.000Z","updated":"2017-04-13T14:35:41.000Z","comments":true,"path":"ARGB与RGBA.html","link":"","permalink":"http://zhanghao.studio/ARGB与RGBA.html","excerpt":"一、写在前面的废话今天在rn中调整一个view的backgroudColor时，想设置透明度适中的色值，按照Android原生代码的习惯写成’#77000000’。这种写法在Android项目的xml文件中是没问题的，但是放在js文件的Style中就是不起作用，查了一下，色值有argb和rgba两种格式。","text":"一、写在前面的废话今天在rn中调整一个view的backgroudColor时，想设置透明度适中的色值，按照Android原生代码的习惯写成’#77000000’。这种写法在Android项目的xml文件中是没问题的，但是放在js文件的Style中就是不起作用，查了一下，色值有argb和rgba两种格式。 二、ARGB在Android中颜色值通常遵循RGB/ARGB的标准，以“#”开头，以16进制表示，常用的格式为 1234#RGB#RRGGBB#ARGB#AARRGGBB 上面四个字母都很容易理解，分别是Alpha,Red,Green,Blue。透明度分为256阶（0-255），计算机上用16进制表示为（00-ff）。透明就是0阶，不透明就是255阶,如果50%透明就是127阶。 三、RGBA这四个字母的意思跟上面讲的完全一样，只是透明度放到了最后。粗略的查了一下，RGBA是CSS3标准（这属于前端的知识范畴了，有机会再去学习）新增的，CSS2中色彩模式只有RGB色彩模式和十六进制模式。 我个人理解，这两种格式只是顺序上不同，应用于不同的编程语言中。需要记住，react native中是将表示透明度的两位十六进制数放在最后。","categories":[{"name":"react native","slug":"react-native","permalink":"http://zhanghao.studio/categories/react-native/"}],"tags":[{"name":"react native","slug":"react-native","permalink":"http://zhanghao.studio/tags/react-native/"}]},{"title":"清单文件中activity属性windowSoftInputMode研究","slug":"清单文件中activity属性windowSoftInputMode研究","date":"2017-02-20T16:15:08.000Z","updated":"2017-02-21T16:02:54.000Z","comments":true,"path":"清单文件中activity属性windowSoftInputMode研究.html","link":"","permalink":"http://zhanghao.studio/清单文件中activity属性windowSoftInputMode研究.html","excerpt":"一、写在前面的废话: 今天研究聊天详情页时，发现点击输入框获得焦点后，弹起的软键盘没有盖住EditText,而是将输入框顶了上去。一番搜索，原来是通过在清单文件中给对应activity设置属性windowSoftInputMode做到的。接下来就研究一下这个属性吧。","text":"一、写在前面的废话: 今天研究聊天详情页时，发现点击输入框获得焦点后，弹起的软键盘没有盖住EditText,而是将输入框顶了上去。一番搜索，原来是通过在清单文件中给对应activity设置属性windowSoftInputMode做到的。接下来就研究一下这个属性吧。 二、知识点：​ windowSoftInputMode可以取九个值，分别是： android:windowSoftInputMode=[&quot;stateUnspecified&quot;, &quot;stateUnchanged&quot;, &quot;stateHidden&quot;, &quot;stateAlwaysHidden&quot;, &quot;stateVisible&quot;, &quot;stateAlwaysVisible&quot;, &quot;adjustUnspecified&quot;, &quot;adjustResize&quot;, &quot;adjustPan&quot;] ​ 从命名就可以看出，前六个值跟状态有关，后三个值跟布局的调整有关。关于这两类取值，可以看google官方API给出的解释: The state of the soft keyboard — whether it is hidden or visible — when the activity becomes the focus of user attention.The adjustment made to the activity’s main window — whether it is resized smaller to make room for the soft keyboard or whether its contents pan to make the current focus visible when part of the window is covered by the soft keyboard. ​ 前者是当activity获得用户的焦点时，软键盘是弹出还是隐藏；后者是，当软键盘弹出的时候，当前activity的主窗口是否缩小布局以使软键盘有足够的空间展示，或者使布局里的内容向上滑动以使当前获得焦点的View可见。 The setting must be one of the values listed in the following table, or a combination of one “state...“ value plus one “adjust...“ value. Setting multiple values in either group — multiple “state...“ values, for example — has undefined results. Individual values are separated by a vertical bar (|). For example: ​ 这段话指出，这个属性必须从九个值里取，可以只取一个值，也可以是 state…与adjust的组合，如下： 1&lt;activity android:windowSoftInputMode=\"stateVisible|adjustResize\" . . . &gt; ​ 关于九个值各自的介绍，官方也给出了解释： Value Description stateUnspcified The state of the soft keyboard (whether it is hidden or visible) is not specified. The system will choose an appropriate state or rely on the setting in the theme.This is the default setting for the behavior of the soft keyboard. (这个是默认缺省属性值，显示或者隐藏由系统来确定，或者由当前主题来确定) stateUnchanged The soft keyboard is kept in whatever state it was last in, whether visible or hidden, when the activity comes to the fore.(经测试，似乎没什么卵用。) stateHidden The soft keyboard is hidden when the user chooses the activity — that is, when the user affirmatively navigates forward to the activity, rather than backs into it because of leaving another activity. stateAlwaysHidden The soft keyboard is always hidden when the activity’s main window has input focus. stateVisible The soft keyboard is visible when that’s normally appropriate (when the user is navigating forward to the activity’s main window). stateAlwaysVisible The soft keyboard is made visible when the user chooses the activity — that is, when the user affirmatively navigates forward to the activity, rather than backs into it because of leaving another activity.(设置了这个值或上一个，通过测试发现，进入activity后，软键盘会自动弹起。而设置stateHidden和stateAlwaysHidden则不会。) adjustUnspecified It is unspecified whether the activity’s main window resizes to make room for the soft keyboard, or whether the contents of the window pan to make the current focus visible on-screen. The system will automatically select one of these modes depending on whether the content of the window has any layout views that can scroll their contents. If there is such a view, the window will be resized, on the assumption that scrolling can make all of the window’s contents visible within a smaller area.This is the default setting for the behavior of the main window.(缺省值，到底是缩小布局还是滚动布局中获得焦点控件以上的组件，取决于当前布局中是否有可以滚动的View。) adjustResize The activity’s main window is always resized to make room for the soft keyboard on screen.(触发View的onSizeChanged方法，布局高度缩小了，给软键盘腾出空间。) adjustPan The activity’s main window is not resized to make room for the soft keyboard. Rather, the contents of the window are automatically panned so that the current focus is never obscured by the keyboard and users can always see what they are typing. This is generally less desirable than resizing, because the user may need to close the soft keyboard to get at and interact with obscured parts of the window. ​ 妈蛋的，上面的属性值我挨个试了一遍，但与它给出的结果不一致，我都糊涂了。不过，我发现几个比较靠谱的规律： 用的比较多的是adjustResize和adjustPan，前者是缩小布局得大小，后者是向上移动焦点控件之上的View。 当布局中，焦点组件上方有可滚动的View时，设置为adjustPan，会将当前焦点组件上方的所有View向上移动，以使得焦点组件完全露出，且焦点组件下方的View被软键盘遮盖，这种会导致View被顶出界面；设置为adjustResize，可滚动的View会缩小其高度，给软键盘腾出空间，然后其中焦点组件上方的View会向上滚动，这样可滚动的View上方的View不会滚动，即保持位置不变。 如果焦点组件上方没有可滚动的View，设置为adjustPan，跟上面效果一样；设置为adjustResize，不起作用，焦点组件被盖住了！","categories":[{"name":"android","slug":"android","permalink":"http://zhanghao.studio/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://zhanghao.studio/tags/android/"}]},{"title":"第一篇——利用hexo和github搭建静态博客","slug":"第一篇——利用hexo和github搭建静态博客","date":"2017-02-19T15:52:16.000Z","updated":"2017-04-12T17:37:00.000Z","comments":true,"path":"第一篇——利用hexo和github搭建静态博客.html","link":"","permalink":"http://zhanghao.studio/第一篇——利用hexo和github搭建静态博客.html","excerpt":"最近一周，效率实在不高，某些逻辑我还是一团浆糊。回到家也没有接触别的知识，惭愧不已，这个周日的晚上逼自己将4个月前挖的坑填上，利用hexo和github pages 搭建自己的静态Blog。","text":"最近一周，效率实在不高，某些逻辑我还是一团浆糊。回到家也没有接触别的知识，惭愧不已，这个周日的晚上逼自己将4个月前挖的坑填上，利用hexo和github pages 搭建自己的静态Blog。 教程可以参考这篇文章 传送门 。 坑还没有填满，下次再研究一下： md的语法 添加评论的功能—多说 不蒜子的统计 主题美化 2017–03-26 我来填坑了。 markdown 语法 写了几篇博客，把常用的都记住了，还有一些等以后补充吧。以下都在语法前面加了转义字符”\\”。 # 标题，最多六个，既一级标题到六级标题 [显示的文字](url) 网站的超链接 ![显示的文字](url) 网络图片 > 引用文字 `` 代码 三个` 代码块，后面还可以跟语言名字来显示不同的高亮 - 无序列表 数字 + . + 空格 有序列表 评论 之前看hexo的教程，大多数博主用的社会化评论系统都是多说，但是，多说官方最近宣布即将关闭，传送门，这真是一个悲伤的故事。再查教程，发现正在用的next主题支持多种评论系统，传送门，考虑到稳定性和墙的因素，暂时采用了来必力。配置十分简单，如下： 登陆 来必力 获取你的 LiveRe UID。 编辑 next 主题配置文件， 编辑 livere_uid 字段，设置为 livere_uid: #your livere_uid 不蒜子统计功能 ，照搬官方教程 全局配置 编辑 主题配置文件 中的busuanzi_count的配置项。当enable: true时，代表开启全局开关。若site_uv、site_pv、page_pv的值均为false时，不蒜子仅作记录而不会在页面上显示。 站点UV配置 当site_uv: true时，代表在页面底部显示站点的UV值。 site_uv_header和site_uv_footer为自定义样式配置，相关的值留空时将不显示，可以使用（带特效的）font-awesome。显示效果为[site_uv_header]UV值[site_uv_footer]。 12345&gt; # 效果：本站访客数12345人次&gt; site_uv: true&gt; site_uv_header: 本站访客数&gt; site_uv_footer: 人次&gt; 站点PV配置 当site_pv: true时，代表在页面底部显示站点的PV值。 site_pv_header和site_pv_footer为自定义样式配置，相关的值留空时将不显示，可以使用（带特效的）font-awesome。显示效果为[site_pv_header]PV值[site_pv_footer]。 123456&gt;&gt; # 效果：本站总访问量12345次&gt; site_pv: true&gt; site_pv_header: 本站总访问量&gt; site_pv_footer: 次&gt; 单页面PV配置 当page_pv: true时，代表在文章页面的标题下显示该页面的PV值（阅读数）。 page_pv_header和page_pv_footer为自定义样式配置，相关的值留空时将不显示，可以使用（带特效的）font-awesome。显示效果为[page_pv_header]PV值[page_pv_footer]。 12345&gt; # 效果：本文总阅读量12345次&gt; page_pv: true&gt; page_pv_header: 本文总阅读量&gt; page_pv_footer: 次&gt; 主题美化 之前用的是 yilia，作者的blog。后来发现了更适合我口味的next，文档详细，配置简单，学习成本低，强烈推荐。","categories":[{"name":"hexo","slug":"hexo","permalink":"http://zhanghao.studio/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://zhanghao.studio/tags/hexo/"}]}]}