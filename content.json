{"meta":{"title":"My World","subtitle":"Talk is cheap,show me your code!","description":null,"author":"张昊","url":"http://zhanghao.studio"},"pages":[{"title":"标签~","date":"2017-03-23T16:18:33.000Z","updated":"2017-04-12T17:33:25.000Z","comments":false,"path":"tags/index.html","permalink":"http://zhanghao.studio/tags/index.html","excerpt":"","text":""},{"title":"分类~","date":"2017-04-12T17:31:16.000Z","updated":"2017-04-12T17:34:12.000Z","comments":false,"path":"categories/index.html","permalink":"http://zhanghao.studio/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"开源项目——ButterKnife","slug":"开源项目——ButterKnife","date":"2017-11-08T16:20:45.000Z","updated":"2017-12-25T15:18:02.761Z","comments":true,"path":"开源项目——ButterKnife.html","link":"","permalink":"http://zhanghao.studio/开源项目——ButterKnife.html","excerpt":"前言从 ButterKnife 开始，我会不定时研究常用Android开源项目，梳理它们各自的原理，并沉淀为技术文章，敬请期待。","text":"前言从 ButterKnife 开始，我会不定时研究常用Android开源项目，梳理它们各自的原理，并沉淀为技术文章，敬请期待。 正文概要ButterKnife 提供了很多自定义注解，最常用的就是 @BindView 和 @OnClick， 然后由自定义APT（注解处理器）在编译时生成绑定 View 和点击事件的代码。在获取类 xxx_ViewBinding 的对象时，借助了 Java 反射。 源码跟踪我阅读的是 8.2.1 版本的源码，它的使用不具体介绍了，不同的版本，注解名可能会有变动，建议直接看 GitHub 上的 ReadMe 。 在某个要使用 ButterKnife 的 activity 中，我们需要在 OnCreate() 方法中添加代码： 1ButterKnife.bind(this); 进入 bind(this) 方法： 12345@NonNull @UiThreadpublic static Unbinder bind(@NonNull Activity target) &#123; View sourceView = target.getWindow().getDecorView(); return createBinding(target, sourceView);&#125; getDecorView() 获取到 window 中的最顶层 View，然后传入 createBinding (); 123456789101112131415private static Unbinder createBinding(@NonNull Object target, @NonNull View source) &#123; Class&lt;?&gt; targetClass = target.getClass(); if (debug) Log.d(TAG, \"Looking up binding for \" + targetClass.getName()); Constructor&lt;? extends Unbinder&gt; constructor = findBindingConstructorForClass(targetClass); if (constructor == null) &#123; return Unbinder.EMPTY; &#125; try &#123; return constructor.newInstance(target, source); &#125; //······省略部分 try/catch 代码 &#125; 首先获取到该 activity 的 Class 对象，将其传入 findBindingConstructorForClass(): 1234567891011121314151617181920212223242526@Nullable @CheckResult @UiThreadprivate static Constructor&lt;? extends Unbinder&gt; findBindingConstructorForClass(Class&lt;?&gt; cls) &#123; Constructor&lt;? extends Unbinder&gt; bindingCtor = BINDINGS.get(cls); if (bindingCtor != null) &#123; if (debug) Log.d(TAG, \"HIT: Cached in binding map.\"); return bindingCtor; &#125; String clsName = cls.getName(); if (clsName.startsWith(\"android.\") || clsName.startsWith(\"java.\")) &#123; if (debug) Log.d(TAG, \"MISS: Reached framework class. Abandoning search.\"); return null; &#125; try &#123; Class&lt;?&gt; bindingClass = cls.getClassLoader().loadClass(clsName + \"_ViewBinding\"); //noinspection unchecked bindingCtor = (Constructor&lt;? extends Unbinder&gt;) bindingClass.getConstructor(cls, View.class); if (debug) Log.d(TAG, \"HIT: Loaded binding class and constructor.\"); &#125; catch (ClassNotFoundException e) &#123; if (debug) Log.d(TAG, \"Not found. Trying superclass \" + cls.getSuperclass().getName()); bindingCtor = findBindingConstructorForClass(cls.getSuperclass()); &#125; catch (NoSuchMethodException e) &#123; throw new RuntimeException(\"Unable to find binding constructor for \" + clsName, e); &#125; BINDINGS.put(cls, bindingCtor); return bindingCtor;&#125; BINDERS 是一个 LinkedHashMap ,用来缓存 clsName_ViewBinding 的构造器对象，避免下次调用继续使用反射影响性能。若缓存中没有，通过 Class 的 getClassLoader() 加载该类，然后用反射得到构造器对象，并放入 map。 然后调用 newInstance() 生成 clsName_ViewBinding 的实例。 12345678910111213141516171819202122232425262728293031323334public class MainActivity_ViewBinding implements Unbinder &#123; private MainActivity target; private View view2131427422; //······略 @UiThread public MainActivity_ViewBinding(final MainActivity target, View source) &#123; this.target = target; View view; view = Utils.findRequiredView(source, R.id.text, \"field 'textView' and method 'onViewClicked'\"); target.textView = Utils.castView(view, R.id.text, \"field 'textView'\", TextView.class); view2131427422 = view; view.setOnClickListener(new DebouncingOnClickListener() &#123; @Override public void doClick(View p0) &#123; target.onViewClicked(p0); &#125; &#125;); &#125; @Override @CallSuper public void unbind() &#123; MainActivity target = this.target; if (target == null) throw new IllegalStateException(\"Bindings already cleared.\"); //解绑时释放持有的引用（view 和点击事件） this.target = null; target.textView = null; view2131427422.setOnClickListener(null); view2131427422 = null; &#125;&#125; 构造方法里的 Utils.findRequiredView 调用了 View 的 findViewById() 实现对 view 的绑定，并强制转换为声明的类型。需要注意的是，因为通过 target.xxx 来赋值，所以我们不能将 View 定义为 private 的。变量 view2131427422 是为了解绑时释放对 OnClickListener 的引用，所以该变量的数目取决于 @OnClick 中 View Id 的数目。 看到这里，我们对 ButterKnife 的核心流程有个大致了解了。但你肯定很好奇，xxx_ViewBinding 是怎么生成的？这就是 APT（注解处理器） 干的活啦。 APT 和 ButterKnifeProcessor APT(Annotation Processing Tools) 的原理是在某些代码元素上（如类型、函数、字段等）添加注解，在编译时编译器会检查 AbstractProcessor 的子类，并且调用该类型的 process 函数，然后将添加了注解的所有元素都传递到 process 函数中，使得开发人员可以在编译器进行相应的处理，例如，根据注解生成新的Java类，这也就是EventBus，Retrofit，Dragger等开源库的基本原理。 init(ProcessingEnvironment env)我们先来看看 ButterKnifeProcessor 中的 init(ProcessingEnvironment env) 方法： 1234567891011121314151617181920212223@Override public synchronized void init(ProcessingEnvironment env) &#123; super.init(env); String sdk = env.getOptions().get(OPTION_SDK_INT); if (sdk != null) &#123; try &#123; this.sdk = Integer.parseInt(sdk); &#125; catch (NumberFormatException e) &#123; env.getMessager() .printMessage(Kind.WARNING, \"Unable to parse supplied minSdk option '\" + sdk + \"'. Falling back to API 1 support.\"); &#125; &#125; // 得到一些有用的工具类 elementUtils = env.getElementUtils(); typeUtils = env.getTypeUtils(); filer = env.getFiler(); try &#123; trees = Trees.instance(processingEnv); &#125; catch (IllegalArgumentException ignored) &#123; &#125;&#125; 在 init 中主要根据 env 得到一些工具类。其中的 filter 主要是用来生成 Java 代码，而 elementUtils 和 typeUtils 会在下面源码中用到。 getSupportedAnnotationTypes()123456789101112131415161718192021222324252627282930313233343536373839404142private static final List&lt;Class&lt;? extends Annotation&gt;&gt; LISTENERS = Arrays.asList( OnCheckedChanged.class, OnClick.class, OnEditorAction.class, OnFocusChange.class, OnItemClick.class, OnItemLongClick.class, OnItemSelected.class, OnLongClick.class, OnPageChange.class, OnTextChanged.class, OnTouch.class);@Override public Set&lt;String&gt; getSupportedAnnotationTypes() &#123; // 返回注解处理器支持处理的注解 Set&lt;String&gt; types = new LinkedHashSet&lt;&gt;(); for (Class&lt;? extends Annotation&gt; annotation : getSupportedAnnotations()) &#123; types.add(annotation.getCanonicalName()); &#125; return types;&#125;// 得到所有的注解private Set&lt;Class&lt;? extends Annotation&gt;&gt; getSupportedAnnotations() &#123; Set&lt;Class&lt;? extends Annotation&gt;&gt; annotations = new LinkedHashSet&lt;&gt;(); annotations.add(BindArray.class); annotations.add(BindBitmap.class); annotations.add(BindBool.class); annotations.add(BindColor.class); annotations.add(BindDimen.class); annotations.add(BindDrawable.class); annotations.add(BindFloat.class); annotations.add(BindInt.class); annotations.add(BindString.class); annotations.add(BindView.class); annotations.add(BindViews.class); annotations.addAll(LISTENERS); return annotations;&#125; getSupportedAnnotationTypes() 方法的作用就是返回该注解处理器所支持处理的注解集合。 process(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env)这是注解处理器中最重要的方法。 1234567891011121314151617@Override public boolean process(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env) &#123; // 扫描所有注解，最后生成 map Map&lt;TypeElement, BindingSet&gt; bindingMap = findAndParseTargets(env); // 遍历 bindingMap 并且通过 Filer 生成 Java 代码 for (Map.Entry&lt;TypeElement, BindingSet&gt; entry : bindingMap.entrySet()) &#123; TypeElement typeElement = entry.getKey(); BindingSet binding = entry.getValue(); JavaFile javaFile = binding.brewJava(sdk); try &#123; javaFile.writeTo(filer); &#125; catch (IOException e) &#123; error(typeElement, &quot;Unable to write binding for type %s: %s&quot;, typeElement, e.getMessage()); &#125; &#125; return true;&#125; process 方法干了两个活： 扫描所有的注解，然后生成以 TypeElement 为 key ，BindingSet 为 value 的 Map ； 遍历生成的 Map，通过 Filter 来生成对应的辅助类源码，这里使用了 JavaPoet 来生成 Java 源码，可以阅读这篇文章 《javapoet——让你从重复无聊的代码中解放出来》 。 findAndParseTargets(env)1234567891011121314151617181920212223242526// 扫描所有的ButterKnife注解，并且生成以TypeElement为键，BindingSet为值的HashMapprivate Map&lt;TypeElement, BindingSet&gt; findAndParseTargets(RoundEnvironment env) &#123; Map&lt;TypeElement, BindingSet.Builder&gt; builderMap = new LinkedHashMap&lt;&gt;(); Set&lt;TypeElement&gt; erasedTargetNames = new LinkedHashSet&lt;&gt;(); scanForRClasses(env); // 省略一堆解析各种注解的源码，这些源码做的事情和下面这个 for 循环一样 // 所以只要看这个解析 @BindView 就够了 ... // Process each @BindView element. // 遍历所有被 @BindView 标注的元素 for (Element element : env.getElementsAnnotatedWith(BindView.class)) &#123; // we don't SuperficialValidation.validateElement(element) // so that an unresolved View type can be generated by later processing rounds try &#123; parseBindView(element, builderMap, erasedTargetNames); &#125; catch (Exception e) &#123; logParsingError(element, BindView.class, e); &#125; &#125; ... &#125; 先来看关于 BindView 的那个 for 循环，它会遍历所有被 @BindView 注解的属性，然后调用 parseBindView方法。 parseBindView1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768private void parseBindView(Element element, Map&lt;TypeElement, BindingSet.Builder&gt; builderMap,Set&lt;TypeElement&gt; erasedTargetNames) &#123; // 得到注解 @BindView 元素所在的类元素 TypeElement enclosingElement = (TypeElement) element.getEnclosingElement(); // Start by verifying common generated code restrictions. // ---------- 类型校验逻辑 start --------------- // 判断是否被注解在属性上，如果该属性是被 private 或者 static 修饰的，则出错 // 判断是否被注解在错误的包中，若包名以“android”或者“java”开头，则出错 boolean hasError = isInaccessibleViaGeneratedCode(BindView.class, \"fields\", element) || isBindingInWrongPackage(BindView.class, element); // Verify that the target type extends from View. TypeMirror elementType = element.asType(); if (elementType.getKind() == TypeKind.TYPEVAR) &#123; TypeVariable typeVariable = (TypeVariable) elementType; elementType = typeVariable.getUpperBound(); &#125; // 判断元素是不是View及其子类或者Interface if (!isSubtypeOfType(elementType, VIEW_TYPE) &amp;&amp; !isInterface(elementType)) &#123; if (elementType.getKind() == TypeKind.ERROR) &#123; note(element, \"@%s field with unresolved type (%s) \" + \"must elsewhere be generated as a View or interface. (%s.%s)\", BindView.class.getSimpleName(), elementType, enclosingElement.getQualifiedName(), element.getSimpleName()); &#125; else &#123; error(element, \"@%s fields must extend from View or be an interface. (%s.%s)\", BindView.class.getSimpleName(), enclosingElement.getQualifiedName(), element.getSimpleName()); hasError = true; &#125; &#125; // 如果有错误 不执行下面代码 if (hasError) &#123; return; &#125; //---------------- 类型校验逻辑 end ----------------- // Assemble information on the field. //得到被注解的注解值，即 R.id.xxx int id = element.getAnnotation(BindView.class).value(); // 根据所在的类元素去查找 builder BindingSet.Builder builder = builderMap.get(enclosingElement); // 如果相应的 builder 已经存在 if (builder != null) &#123; // 得到相对应的 View 绑定的属性名 String existingBindingName = builder.findExistingBindingName(getId(id)); // 若该属性名已经存在，则说明之前已经绑定过，会报错 if (existingBindingName != null) &#123; error(element, \"Attempt to use @%s for an already bound ID %d on '%s'. (%s.%s)\", BindView.class.getSimpleName(), id, existingBindingName, enclosingElement.getQualifiedName(), element.getSimpleName()); return; &#125; &#125; else &#123; // 如果没有对应的 builder ，就通过 getOrCreateBindingBuilder 方法生成，并且放入 builderMap 中 builder = getOrCreateBindingBuilder(builderMap, enclosingElement); &#125; // 得到注解名 String name = element.getSimpleName().toString(); // 得到注解元素的类型 TypeName type = TypeName.get(elementType); boolean required = isFieldRequired(element); // 根据 id ，添加相对应的 Field 的绑定信息 builder.addField(getId(id), new FieldViewBinding(name, type, required)); // Add the type-erased version to the valid binding targets set. // 添加到待 unbind 的序列中 erasedTargetNames.add(enclosingElement);&#125; 在 parseBindView 方法中基本上都加了注释，在方法的开头会对该 element 去做校验。如果校验没通过的话，就没有下面代码的什么事了。若校验通过之后，生成该 element 所在的类元素对应的 builder ，builder 中添加相应的 Field 绑定信息，最后添加到待 unbind 的序列中去。 现在，我们回过头来看看 findAndParseTargets(env) 方法的后半段： 12345678910111213141516171819202122232425262728293031323334353637private Map&lt;TypeElement, BindingSet&gt; findAndParseTargets(RoundEnvironment env) &#123; ... // 省略前半部分源码 // Associate superclass binders with their subclass binders. This is a queue-based tree walk // which starts at the roots (superclasses) and walks to the leafs (subclasses). Deque&lt;Map.Entry&lt;TypeElement, BindingSet.Builder&gt;&gt; entries = new ArrayDeque&lt;&gt;(builderMap.entrySet()); Map&lt;TypeElement, BindingSet&gt; bindingMap = new LinkedHashMap&lt;&gt;(); while (!entries.isEmpty()) &#123; // 一个个取出遍历 Map.Entry&lt;TypeElement, BindingSet.Builder&gt; entry = entries.removeFirst(); // 得到对应的 key 和 value TypeElement type = entry.getKey(); BindingSet.Builder builder = entry.getValue(); // 找到该类元素的父元素 TypeElement parentType = findParentType(type, erasedTargetNames); if (parentType == null) &#123; // 生成 BindingSet ，放入 Map 中 bindingMap.put(type, builder.build()); &#125; else &#123; BindingSet parentBinding = bindingMap.get(parentType); if (parentBinding != null) &#123; // 设置父元素的 BindingSet builder.setParent(parentBinding); bindingMap.put(type, builder.build()); &#125; else &#123; // Has a superclass binding but we haven't built it yet. Re-enqueue for later. // 有父元素，但是父元素的 BindingSet 还没有被 build 出来， // 所以再放入 entries 中等待遍历 entries.addLast(entry); &#125; &#125; &#125; // 解析结果都会存放在 bindingMap 中 return bindingMap;&#125; 主要就是把之前的 builderMap 转换为了 bindingMap 并返回。到了这里，我们把 process(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env) 做的第一件事情搞清楚了，下面就接着来看第二件事情了。 123456789101112// 遍历 bindingMap 并且通过 Filer 生成 Java 代码for (Map.Entry&lt;TypeElement, BindingSet&gt; entry : bindingMap.entrySet()) &#123; TypeElement typeElement = entry.getKey(); BindingSet binding = entry.getValue(); JavaFile javaFile = binding.brewJava(sdk); try &#123; javaFile.writeTo(filer); &#125; catch (IOException e) &#123; error(typeElement, \"Unable to write binding for type %s: %s\", typeElement, e.getMessage()); &#125;&#125; brewJava(int sdk) 和 createType(int sdk)从上面可以看到，遍历了之前得到的 bindingMap ，然后利用 binding 中的信息生成相应的 Java 源码。所以在 binding.brewJava(sdk) 这个方法是我们重点关注对象。那么就进入 BindingSet 中去看看吧： 123456JavaFile brewJava(int sdk) &#123; // 生成 JavaFile，添加相应的注释 return JavaFile.builder(bindingClassName.packageName(), createType(sdk)) .addFileComment(&quot;Generated code from Butter Knife. Do not modify!&quot;) .build();&#125; 就是利用了 JavaFile.builder 生成了一个 JavaFile 对象。但是我们发现其中有一个 createType(int sdk) 方法，继续跟进去看： 1234567891011121314151617181920212223242526272829303132333435363738private TypeSpec createType(int sdk) &#123; // 生成类名为 bindingClassName 的公共类，比如 MainActivity_ViewBinding TypeSpec.Builder result = TypeSpec.classBuilder(bindingClassName.simpleName()) .addModifiers(PUBLIC); // 是否修饰为 final ，默认是 false if (isFinal) &#123; result.addModifiers(FINAL); &#125; if (parentBinding != null) &#123; // 如果有父类的话，那么要继承父类 result.superclass(parentBinding.bindingClassName); &#125; else &#123; // 如果没有父类，那么实现 Unbinder 接口 result.addSuperinterface(UNBINDER); &#125; // 增加一个变量名为target，类型为targetTypeName的成员变量 if (hasTargetField()) &#123; result.addField(targetTypeName, \"target\", PRIVATE); &#125; // 如果没有 View 绑定 if (!constructorNeedsView()) &#123; // Add a delegating constructor with a target type + view signature for reflective use. // 该生成的构造方法被 @deprecated ，一般作为反射使用 result.addMethod(createBindingViewDelegateConstructor(targetTypeName)); &#125; // 生成构造方法，另外 findViewById 类似的代码都在这里生成 // Xxxx_ViewBinding 一般都是执行这个方法生成构造器 result.addMethod(createBindingConstructor(targetTypeName, sdk)); if (hasViewBindings() || parentBinding == null) &#123; //生成unBind方法 result.addMethod(createBindingUnbindMethod(result, targetTypeName)); &#125; return result.build();&#125; 在 createType(int sdk) 方法中，基本构建好了一个类的大概，其中对于构造器以及类似 findViewById 的操作都是在 createBindingConstructor(targetTypeName, sdk) 中实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879private MethodSpec createBindingConstructor(TypeName targetType, int sdk) &#123; // 创建构造方法，方法修饰符为 public ，并且添加注解为UiThread MethodSpec.Builder constructor = MethodSpec.constructorBuilder() .addAnnotation(UI_THREAD) .addModifiers(PUBLIC); // 如果有方法绑定，比如 @OnClick if (hasMethodBindings()) &#123; // 如果有，那么添加 targetType 类型，final 修饰，参数名为 target 的构造方法参数 constructor.addParameter(targetType, \"target\", FINAL); &#125; else &#123; // 如果没有，和上面比起来就少了一个 final 修饰符 constructor.addParameter(targetType, \"target\"); &#125; // 如果有注解的 View if (constructorNeedsView()) &#123; // 那么添加 View source 参数 constructor.addParameter(VIEW, \"source\"); &#125; else &#123; // 否则添加 Context context 参数 constructor.addParameter(CONTEXT, \"context\"); &#125; if (hasUnqualifiedResourceBindings()) &#123; // Aapt can change IDs out from underneath us, just suppress since all will work at runtime. constructor.addAnnotation(AnnotationSpec.builder(SuppressWarnings.class) .addMember(\"value\", \"$S\", \"ResourceType\") .build()); &#125; // 如果有父类，那么会根据不同情况调用不同的 super 语句 if (parentBinding != null) &#123; if (parentBinding.constructorNeedsView()) &#123; constructor.addStatement(\"super(target, source)\"); &#125; else if (constructorNeedsView()) &#123; constructor.addStatement(\"super(target, source.getContext())\"); &#125; else &#123; constructor.addStatement(\"super(target, context)\"); &#125; constructor.addCode(\"\\n\"); &#125; // 如果有绑定 Field 或者方法，那么添加 this.target = target 语句 if (hasTargetField()) &#123; constructor.addStatement(\"this.target = target\"); constructor.addCode(\"\\n\"); &#125; // 如果有 View 绑定 if (hasViewBindings()) &#123; if (hasViewLocal()) &#123; // Local variable in which all views will be temporarily stored. constructor.addStatement(\"$T view\", VIEW); &#125; for (ViewBinding binding : viewBindings) &#123; // 为 View 绑定生成类似于 findViewById 之类的代码 addViewBinding(constructor, binding); &#125; // 为 View 的集合或者数组绑定 for (FieldCollectionViewBinding binding : collectionBindings) &#123; constructor.addStatement(\"$L\", binding.render()); &#125; if (!resourceBindings.isEmpty()) &#123; constructor.addCode(\"\\n\"); &#125; &#125; // 绑定 resource 资源的代码 if (!resourceBindings.isEmpty()) &#123; if (constructorNeedsView()) &#123; constructor.addStatement(\"$T context = source.getContext()\", CONTEXT); &#125; if (hasResourceBindingsNeedingResource(sdk)) &#123; constructor.addStatement(\"$T res = context.getResources()\", RESOURCES); &#125; for (ResourceBinding binding : resourceBindings) &#123; constructor.addStatement(\"$L\", binding.render(sdk)); &#125; &#125; return constructor.build();&#125; 通过上面的代码就生成了构造器， findViewById 都在 addViewBinding(constructor, binding) 里会看到： 123456789101112131415161718192021222324252627282930313233343536373839404142private void addViewBinding(MethodSpec.Builder result, ViewBinding binding) &#123; if (binding.isSingleFieldBinding()) &#123; // Optimize the common case where there's a single binding directly to a field. FieldViewBinding fieldBinding = binding.getFieldBinding(); // 注意这里直接使用了 target. 的形式，所以属性肯定是不能 private 的 CodeBlock.Builder builder = CodeBlock.builder() .add(\"target.$L = \", fieldBinding.getName()); // 下面都是 View 绑定的代码 boolean requiresCast = requiresCast(fieldBinding.getType()); if (!requiresCast &amp;&amp; !fieldBinding.isRequired()) &#123; builder.add(\"source.findViewById($L)\", binding.getId().code); &#125; else &#123; builder.add(\"$T.find\", UTILS); builder.add(fieldBinding.isRequired() ? \"RequiredView\" : \"OptionalView\"); if (requiresCast) &#123; builder.add(\"AsType\"); &#125; builder.add(\"(source, $L\", binding.getId().code); if (fieldBinding.isRequired() || requiresCast) &#123; builder.add(\", $S\", asHumanDescription(singletonList(fieldBinding))); &#125; if (requiresCast) &#123; builder.add(\", $T.class\", fieldBinding.getRawType()); &#125; builder.add(\")\"); &#125; result.addStatement(\"$L\", builder.build()); return; &#125; List&lt;MemberViewBinding&gt; requiredBindings = binding.getRequiredBindings(); if (requiredBindings.isEmpty()) &#123; result.addStatement(\"view = source.findViewById($L)\", binding.getId().code); &#125; else if (!binding.isBoundToRoot()) &#123; result.addStatement(\"view = $T.findRequiredView(source, $L, $S)\", UTILS, binding.getId().code, asHumanDescription(requiredBindings)); &#125; addFieldBinding(result, binding); // OnClick 等监听事件绑定 addMethodBindings(result, binding);&#125; 至此，整个 ButterKnifeProcessor 解析注解、生成 Java 代码的流程就走完了。 结语借鉴了很多大神的文章，非常感谢，也推荐给大家。 ButterKnife源码分析 Java注解处理器 Android中使用AbstractProcessor在编译时生成代码","categories":[{"name":"android","slug":"android","permalink":"http://zhanghao.studio/categories/android/"}],"tags":[{"name":"那些年，那些牛B的开源项目","slug":"那些年，那些牛B的开源项目","permalink":"http://zhanghao.studio/tags/那些年，那些牛B的开源项目/"}]},{"title":"对build.gradle中三个xxxVersion的理解","slug":"对build-gradle中三个xxxVersion的理解","date":"2017-08-09T14:57:19.000Z","updated":"2017-08-09T16:37:00.000Z","comments":true,"path":"对build-gradle中三个xxxVersion的理解.html","link":"","permalink":"http://zhanghao.studio/对build-gradle中三个xxxVersion的理解.html","excerpt":"前言Gradle 作为 android studio 时代官方指定的自动化构建工具，是我们开发任何项目都必不可少的神器，关于它的介绍，请看 stormzhang 的这篇blog。Android 项目的 app module 下的 build.gradle文件中，定义了三个 version ：compiledSdkVersion、minSdkVersion、targetSdkVersion，它们的含义和作用是什么，请看下文分解。","text":"前言Gradle 作为 android studio 时代官方指定的自动化构建工具，是我们开发任何项目都必不可少的神器，关于它的介绍，请看 stormzhang 的这篇blog。Android 项目的 app module 下的 build.gradle文件中，定义了三个 version ：compiledSdkVersion、minSdkVersion、targetSdkVersion，它们的含义和作用是什么，请看下文分解。 正文compiledSdkVersion这个是用来告诉 gradle 用哪个版本的 sdk 来编译你的项目。这意味着你可以使用API版本中包含的Android API功能(以及所有以前的版本)。如果你尝试使用API 16中的功能，但将compileSdkVersion设置为15，则会收到编译错误。如果你的手机版本是15，将compileSdkVersion设置为16，只要你的应用不尝试调用 API 16特有的API，仍然可以在API 15设备上运行。 需要强调的是修改 compileSdkVersion 不会改变运行时的行为。当你修改了 compileSdkVersion 的时候，可能会出现新的编译警告、编译错误，但新的 compileSdkVersion 不会被包含到 APK 中：它纯粹只是在编译的时候使用。（你真的应该修复这些警告，他们的出现一定是有原因的） 因此我们强烈推荐总是使用最新的 SDK 进行编译。在现有代码上使用新的编译检查可以获得很多好处，避免新弃用的 API ，并且为使用新的 API 做好准备。 minSdkVersion这个很好理解，就是当前应用所支持运行的最低系统版本。假设设置为23，如果你的手机系统版本22，是安装不上这个应用的。 在开发时 minSdkVersion 也起到一个重要角色：lint 默认会在项目中运行，它在你使用了高于 minSdkVersion 的 API 时会警告你，帮你避免调用不存在的 API 的运行时问题。如果只在较高版本的系统上才使用某些 API，通常使用运行时检查系统版本的方式解决。 可以看个官方提供的检查系统版本的代码示例： 123456789private void setUpActionBar() &#123; // Make sure we're running on Honeycomb or higher to use ActionBar APIs if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123; ActionBar actionBar = getActionBar(); actionBar.setDisplayHomeAsUpEnabled(true); &#125;else&#123; //nothing &#125;&#125; targetSdkVersion这个是最不好理解的一个。官方解释说，这是 Android 提供向前兼容的主要依据。 这是什么意思呢？随着 Android 系统的升级，某个系统的 API 或者模块的行为可能会发生改变，但是为了保证老 APK 的行为还是和以前兼容。只要 APK 的 targetSdkVersion 不变，即使这个 APK 安装在新 Android 系统上，其行为还是保持老的系统上的行为，这样就保证了系统对老应用的前向兼容性。 这里还是用原文的例子，在 Android 4.4 (API 19）以后，AlarmManager 的 set() 和 setRepeat() 这两个 API 的行为发生了变化。在 Android 4.4 以前，这两个 API 设置的都是精确的时间，系统能保证在 API 设置的时间点上唤醒 Alarm。因为省电原因 Android 4.4 系统实现了 AlarmManager 的对齐唤醒，这两个 API 设置唤醒的时间，系统都对待成不精确的时间，系统只能保证在你设置的时间点之后某个时间唤醒。 这时，虽然 API 没有任何变化，但是实际上 API 的行为却发生了变化，如果老的 APK 中使用了此 API，并且在应用中的行为非常依赖 AlarmManager 在精确的时间唤醒，例如闹钟应用。如果 Android 系统不能保证兼容，老的 APK 安装在新的系统上，就会出现问题。 Android 系统是怎么保证这种兼容性的呢？这时候 targetSdkVersion 就起作用了。APK 在调用系统 AlarmManager 的 set() 或者 setRepeat() 的时候，系统首先会查一下调用的 APK 的 targetSdkVersion 信息，如果小于 19，就还是按照老的行为，即精确设置唤醒时间，否者执行新的行为。 感谢Android targetSdkVersion 原理","categories":[{"name":"android","slug":"android","permalink":"http://zhanghao.studio/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://zhanghao.studio/tags/android/"}]},{"title":"java注解","slug":"java注解","date":"2017-07-16T09:29:36.000Z","updated":"2017-12-04T15:06:52.760Z","comments":true,"path":"java注解.html","link":"","permalink":"http://zhanghao.studio/java注解.html","excerpt":"前言初学 Java 时，注解这部分知识是匆匆略过的，后来开发 Android 过程中遇到 butterknife 等跟注解有关的代码，也只是按照 API 调用，没有深入研究。前几天跟 web 端同事联调时，发现他们代码中用到注解的地方挺多，方法体上方加一行简短的代码，就能实现复杂的业务逻辑。所以今天认真研究一下注解的用法和特性，弥补知识漏洞。","text":"前言初学 Java 时，注解这部分知识是匆匆略过的，后来开发 Android 过程中遇到 butterknife 等跟注解有关的代码，也只是按照 API 调用，没有深入研究。前几天跟 web 端同事联调时，发现他们代码中用到注解的地方挺多，方法体上方加一行简短的代码，就能实现复杂的业务逻辑。所以今天认真研究一下注解的用法和特性，弥补知识漏洞。 Java 中的注解Annotation 是 Java 1.5 中引入的，用来描述 Java 代码的元数据。那什么是元数据呢？下面是wiki的解释： 元资料（Metadata），又称元数据、诠释资料、中介资料、中继资料、后设资料等，为描述其他资料资讯的资料[1]。有三种不同类型的元资料，分别是记叙性元资料、结构性元资料和管理性元资料[2]。 好吧，看了跟没看一样。我个人觉得 annotation 从形式上看类似于注释，可以作用于某个类、方法、变量、参数等，有解释说明某段代码的作用，但它的功能比注释强大得多。 ####注解的作用 标记，用于告诉编译器某些信息 编译时动态处理，如动态生成代码 运行时动态处理，如通过反射获取注解 注解的分类 内置注解（标准注解） Java 提供了三个内置注解，如下所示，都是最常见的 @Deprecated ：表示java不赞成使用这些被描述的对象 @Override ：用来修饰对父类进行重写的方法。如果父类中的方法名称或参数发生改变时，如果子类没有做相应的调整编译器便会报错 @SuppressWarnings ：使编译器忽略掉编译器警告，比如使用了 Deprecated 的类或方法 元注解 元注解就是描述注解的注解，我们可以通过元注解来控制自定义注解的行为 @Documented 标志将此注解包含至 javadoc 中 @Retention 定义注解保存级别 SOURCE：源码时注解，被编译器丢弃 CLASS ：编译时，被编译器记录在class文件中，运行时被VM丢弃，在编译时使用，属于默认配置 RUNTIME：运行时， 被编译器记录在class文件中，运行时可用，被VM保留，所以可以在运行时搭配反射使用 @Target 定义注解适用的目标 TYPE：Class类，接口(包括注解类型或者enum类型) FIELD：属性(包括enum实例) METHOD：方法 PARAMETER：方法参数 CONSTRUCTOR：类构造器 LOCAL_VARIABLE：本地变量 ANNOTATION_TYPE：注解 PACKAGE：包 @Inherited 让一个类和它的子类都包含某个注解 自定义注解 注解的定义类似于接口，不过注解是 @interface 12345678910@Documented @Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)@Inheritedpublic @interface MyAnnotation &#123; String value() default \"xxx\"; String name(); int age(); String[] newNames();&#125; a. 所有方法没有方法体，没有参数没有修饰符，实际只允许 public &amp; abstract 修饰符，默认为 public ，不允许抛异常 b. ⽅法返回值只能是基本类型，String， Class，annotation，enumeration 或者是它们的一维数组 c. 若只有⼀个默认属性，可直接⽤用 value() 函数。一个属性都没有表⽰示该 Annotation 为 Mark Annotation d.可以加 default 表示默认值 下面这段代码演示了如何使用该注解: 123456789@MyAnnotation( value=\"123\"（value有默认值了，这里可以不指定）, name=\"Jakob\", age=37, newNames=&#123;\"Jenkov\", \"Peterson\"&#125;)public class MyClass &#123;&#125; 我们需要为所有的注解元素设值，但有默认值的元素，我们可以不设值。 通过反射获取注解中的信息​ 对于运行时注解，我们可以通过反射机制获得注解信息，以上面的注解为例。 获取类的注解信息 1234567891011public class TestAnnotation &#123; public static void main(String[] args) &#123; //通过反射获得MyClass的注解信息 MyAnnotation myAnnotation = MyClass.class.getAnnotation(MyAnnotation.class); System.out.println(myAnnotation.name()); System.out.println(myAnnotation.value()); ······ &#125;&#125; 获取方法的注解信息 12345678910111213141516public class TestAnnotation &#123; public static void main(String[] args) &#123; Method method = null; try &#123; method = MyClassB.class.getMethod(\"method\"); Annotation annotation = method.getAnnotation(MyAnnotation.class); if (annotation !=null) &#123; MyAnnotation myAnnotation = (MyAnnotation) annotation; System.out.println(\"name: \" + myAnnotation.name()); System.out.println(\"value: \" + myAnnotation.value()); &#125; &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 获取方法参数的注解信息 12345678910111213141516Method method = MyClassC.class.getMethod(\"method\")Annotation[][] parameterAnnotations = method.getParameterAnnotations();Class[] parameterTypes = method.getParameterTypes();int i=0;for(Annotation[] annotations : parameterAnnotations)&#123; Class parameterType = parameterTypes[i++]; for(Annotation annotation : annotations)&#123; if(annotation instanceof MyAnnotation)&#123; MyAnnotation myAnnotation = (MyAnnotation) annotation; System.out.println(\"param: \" + parameterType.getName()); System.out.println(\"name : \" + myAnnotation.name()); System.out.println(\"value: \" + myAnnotation.value()); &#125; &#125;&#125; 请注意Annotation[][] annos = method.getParameterAnnotations()，这得到的是一个二维数组，它是怎么组合的呢 ？举个例子 1public void method(@MyAnnotation1()int id,@MyAnnotation2()String name)&#123;···&#125; 第一个参数的下标是0，第二个参数的下标是1，那么 annos[0][0] = MyAnnotation1,annos[1][0] = MyAnnotation2，参数前可以添加多个注解，所以得到的是个二维数组。 获取变量的注解信息 12345678Field field = MyClassB.class.getField(\"field\");Annotation annotation = field.getAnnotation(MyAnnotation.class);if(annotation instanceof MyAnnotation)&#123; MyAnnotation myAnnotation = (MyAnnotation) annotation; System.out.println(\"name: \" + myAnnotation.name()); System.out.println(\"value: \" + myAnnotation.value());&#125; Android 中的注解关于 Android 中常用的注解，技术小黑屋有一篇文章介绍的很详细(传送门)，我就不写了。现在特别火的Android开源框架，基本都有自定义注解的影子，如ButterKnife、EventBus、Retrofit等。我会另外写博客分析常用开源框架的源码，敬请期待。 以上内容借鉴了很多大神的文章，十分感谢： Java注解详解 详解Java中的注解 java annotation 详解","categories":[{"name":"java","slug":"java","permalink":"http://zhanghao.studio/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://zhanghao.studio/tags/java/"}]},{"title":"Handler不正确使用可能导致内存泄漏","slug":"Handler不正确使用可能导致内存泄漏","date":"2017-04-12T09:43:12.000Z","updated":"2017-04-12T17:35:28.000Z","comments":true,"path":"Handler不正确使用可能导致内存泄漏.html","link":"","permalink":"http://zhanghao.studio/Handler不正确使用可能导致内存泄漏.html","excerpt":"","text":"","categories":[{"name":"android","slug":"android","permalink":"http://zhanghao.studio/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://zhanghao.studio/tags/android/"}]},{"title":"mac下管理多个ssh秘钥对","slug":"mac-os生成多个ssh秘钥对","date":"2017-04-12T03:06:55.000Z","updated":"2017-04-12T17:38:06.000Z","comments":true,"path":"mac-os生成多个ssh秘钥对.html","link":"","permalink":"http://zhanghao.studio/mac-os生成多个ssh秘钥对.html","excerpt":"一、日常废话昨晚看到一篇提升博客访问速度的文章，其中一点是配置多线路解析，国内路线走国内平台，国外线路走 GitHub Pages。其中，作者提到了国内的代码托管平台 Coding，该平台免费提供静态资源托管，所以我们以前利用 hexo搭建的 GitHub Pages 博客也可以轻松迁移过来。具体步骤我写在另一篇博客中，这里不多讲了。","text":"一、日常废话昨晚看到一篇提升博客访问速度的文章，其中一点是配置多线路解析，国内路线走国内平台，国外线路走 GitHub Pages。其中，作者提到了国内的代码托管平台 Coding，该平台免费提供静态资源托管，所以我们以前利用 hexo搭建的 GitHub Pages 博客也可以轻松迁移过来。具体步骤我写在另一篇博客中，这里不多讲了。 二、遇到的问题及解决办法1.问题场景 公司项目托管在 GitLab,个人项目托管在 GitHub 和 Coding，用到三对 ssh 秘钥， Coding 与 GitHub 一样，需要将使用者的公钥上传到服务器以保证安全传输。所以我用下面的命令生成了 Coding平台专用的秘钥对，至于它的原理，另找时间研究吧。 ssh-keygen -t rsa -C &quot;username@email.com&quot; 换mac后我先 clone 的公司的项目，当时生成的秘钥文件是 id_rsa，对应于 GitLab。这次为 Coding 生成的秘钥不能再用默认命名以免覆盖，另取名 coding_key。问题就出在这里，我把 coding_key.pub 中的公钥上传到Coding后，用以下命令测试还是 Permission denied。 ssh -T git@git.coding.net 2.问题的原因参考这里。 每次连接远程A服务器时，本机的ssh客户端默认发送id_rsa（ssh-keygen生成秘钥对时的默认命名）私钥到A服务端进行验证，如果本机只有这一个秘钥对且生成时没有更改默认命名，那自然不会有问题。但如果本机还与B通信，就需要生成另一对秘钥，上传公钥到B。连接B服务器时，ssh客户端发送的仍然是id_rsa,而与B服务器存储的公钥对应不上，自然就报错了。 我想要的是，不同的ssh秘钥对共存且互不干扰，连接 Server 时自动选择对应私钥。 3.解决方案： https://segmentfault.com/q/1010000000835302 https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/ https://my.oschina.net/stefanzhlg/blog/529403 4.我的做法： 上面提到的解决办法，都是先用ssh-add ~/.ssh/xxx将私钥添加到ssh-agent,然后再编写config文件。我实践了一下，发现在mac系统中，使用 ssh-add 添加和编写 config 文件这两步，只要有一步做到就可以满足需求。不知道window 下是不是必须同时实现才可以。","categories":[{"name":"information security","slug":"information-security","permalink":"http://zhanghao.studio/categories/information-security/"}],"tags":[{"name":"ssh","slug":"ssh","permalink":"http://zhanghao.studio/tags/ssh/"}]},{"title":"优化Github Pages访问速度,去除Coding Pages的广告页","slug":"提升博客的访问速度","date":"2017-04-11T16:21:22.000Z","updated":"2017-07-19T12:32:31.000Z","comments":false,"path":"提升博客的访问速度.html","link":"","permalink":"http://zhanghao.studio/提升博客的访问速度.html","excerpt":"Updated at 2017-06-05：前几天访问博客才发现，Coding 给每个绑定了自定义域名的站都加了一个广告页，等5s后才跳转到主页，想去掉也可以，199元飞升黄金段位即可，唉，白银选手都是辣鸡啊。这真是太恶心了，咱们这小站本来就人迹罕至，再加一5s施法前摇，GGWP。政策一出，群情激愤，于是官方针对我等穷sir，推出 “ Hosted by Coding Pages “免广告服务，就是在你的主页某个位置加上这个超链接文本或图片，审核通过既可去除。 文字版需要添加的代码如下： 1&lt;p&gt;Hosted by &lt;a href=\"https://pages.coding.me\" style=\"font-weight: bold\"&gt;Coding Pages&lt;/a&gt;&lt;/p&gt; 我用的是 NEXT 主题，去修改它的源码， /Users/……/……/themes/next/layout/_partials/footer.swig 1234567891011121314151617181920&lt;div class=\"copyright\" &gt; &#123;% set current = date(Date.now(), \"YYYY\") %&#125; &amp;copy; &#123;% if theme.since and theme.since != current %&#125; &#123;&#123; theme.since &#125;&#125; - &#123;% endif %&#125; &lt;span itemprop=\"copyrightYear\"&gt;&#123;&#123; current &#125;&#125;&lt;/span&gt; &lt;span class=\"with-love\"&gt; &lt;i class=\"fa fa-&#123;&#123; theme.authoricon &#125;&#125;\"&gt;&lt;/i&gt; &lt;/span&gt; &lt;span class=\"author\" itemprop=\"copyrightHolder\"&gt;&#123;&#123; config.author &#125;&#125;&lt;/span&gt;&lt;/div&gt;&#123;% if theme.copyright %&#125;&lt;div class=\"powered-by\"&gt; &#123;&#123; __('footer.powered', '&lt;a class=\"theme-link\" href=\"https://hexo.io\"&gt;Hexo&lt;/a&gt;') &#125;&#125;&lt;/div&gt;&lt;div class=\"theme-info\"&gt; &#123;&#123; __('footer.codingPages') &#125;&#125; &lt;a href=\"https://pages.coding.me\" style=\"font-weight: bold\"&gt;Coding Pages&lt;/a&gt;&lt;/div&gt;&#123;% endif %&#125; 修改了最后一段 div 代码，其中footer.codingPages 是我定义的一个常量 “Hosted by” ，这样就改为我的博客底部的样式了。 日常废话GitHub 是程序猿必备神器，通过它不仅能找到各种开源代码，还能快速搭建个人博客，具体教程可以看这 传送门。幸运的是，我们天朝子民访问 GitHub 还不受GFW限制，但毕竟它的老家在国外，访问速度自然有些拙计。如何提升 GitHub 博客的访问速度呢，一番搜索，学到几发新姿势。","text":"Updated at 2017-06-05：前几天访问博客才发现，Coding 给每个绑定了自定义域名的站都加了一个广告页，等5s后才跳转到主页，想去掉也可以，199元飞升黄金段位即可，唉，白银选手都是辣鸡啊。这真是太恶心了，咱们这小站本来就人迹罕至，再加一5s施法前摇，GGWP。政策一出，群情激愤，于是官方针对我等穷sir，推出 “ Hosted by Coding Pages “免广告服务，就是在你的主页某个位置加上这个超链接文本或图片，审核通过既可去除。 文字版需要添加的代码如下： 1&lt;p&gt;Hosted by &lt;a href=\"https://pages.coding.me\" style=\"font-weight: bold\"&gt;Coding Pages&lt;/a&gt;&lt;/p&gt; 我用的是 NEXT 主题，去修改它的源码， /Users/……/……/themes/next/layout/_partials/footer.swig 1234567891011121314151617181920&lt;div class=\"copyright\" &gt; &#123;% set current = date(Date.now(), \"YYYY\") %&#125; &amp;copy; &#123;% if theme.since and theme.since != current %&#125; &#123;&#123; theme.since &#125;&#125; - &#123;% endif %&#125; &lt;span itemprop=\"copyrightYear\"&gt;&#123;&#123; current &#125;&#125;&lt;/span&gt; &lt;span class=\"with-love\"&gt; &lt;i class=\"fa fa-&#123;&#123; theme.authoricon &#125;&#125;\"&gt;&lt;/i&gt; &lt;/span&gt; &lt;span class=\"author\" itemprop=\"copyrightHolder\"&gt;&#123;&#123; config.author &#125;&#125;&lt;/span&gt;&lt;/div&gt;&#123;% if theme.copyright %&#125;&lt;div class=\"powered-by\"&gt; &#123;&#123; __('footer.powered', '&lt;a class=\"theme-link\" href=\"https://hexo.io\"&gt;Hexo&lt;/a&gt;') &#125;&#125;&lt;/div&gt;&lt;div class=\"theme-info\"&gt; &#123;&#123; __('footer.codingPages') &#125;&#125; &lt;a href=\"https://pages.coding.me\" style=\"font-weight: bold\"&gt;Coding Pages&lt;/a&gt;&lt;/div&gt;&#123;% endif %&#125; 修改了最后一段 div 代码，其中footer.codingPages 是我定义的一个常量 “Hosted by” ，这样就改为我的博客底部的样式了。 日常废话GitHub 是程序猿必备神器，通过它不仅能找到各种开源代码，还能快速搭建个人博客，具体教程可以看这 传送门。幸运的是，我们天朝子民访问 GitHub 还不受GFW限制，但毕竟它的老家在国外，访问速度自然有些拙计。如何提升 GitHub 博客的访问速度呢，一番搜索，学到几发新姿势。 各种姿势 迁移到国内平台 将博客部署到国产代码托管平台，我用的是 Coding。实现步骤跟 GitHub 类似，可以参考 官方教程。 我在添加新的ssh公钥到 Coding 时，遇到了问题，请看 mac下管理多个ssh秘钥对。将代码部署到 Coding 上后，我们得到了一个新的域名，xxx.coding.me，修改一下博客根目录下的配置文件 _config.yml，在 deploy 项下添加 Coding对应的 repo，这样每次执行 hexo d 命令之后，博客内容就会分别部署到 GitHub 和 Coding 了。 绑定一个域名，实现双线访问 如上文所说，迁移到国内平台后，我们又得到一个域名。但是对于同一个博客来说，没有必要，也不利于传播。所以我在万网上买了个域名，即 zhanghao.studio，通过设置域名解析，实现一个域名，双线访问。 首先设置域名解析，下图是万网的域名管理界面： 点击解析后进到编辑界面，万网的记录线路类型有很多，关于每种类型的介绍如下图： 我用到的只有 CNAME 和 A 类型两种，前者的记录值是某一域名，后者记录值是 ip 地址。主机记录填www，会将 zhanghao.studio解析成www.zhanghao.studio；不填则显示为@，直接解析成zhanghao.studio。解析线路有很多，国内访问设置为默认，国外访问设置为海外。记录值是 GitHub 和 Coding 提供的域名，如下图。 到这一步，我们完成了一半的设置，剩下一半的是去 GitHub 和 Coding 绑定你买的域名。 Coding： 进到你托管博客代码的仓库，再进入 Pages 服务，即可看到如上所示界面。Coding 可以绑定5个自定义域名，而 GitHub只能绑定1个。 GitHub： 绑定 GitHub 时需要注意，如果你想像我一样绑定顶级域名 xxx.com，而不加前缀 www，那么必须用 A 记录类型的，详情看 GitHub 官方教程。 至此，我们便实现了博客的双线访问，国内访问走 Coding Pages，国外走GitHub Pages。 利用 CDN 内容分发网络（Content delivery network或Content distribution network，缩写：CDN）是指一种通过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。 对于 CDN ，我仅仅只是了解了一下，就不多讲了。优化思路来自 Next 主题的官方文档 进阶设定。","categories":[{"name":"hexo","slug":"hexo","permalink":"http://zhanghao.studio/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://zhanghao.studio/tags/hexo/"}]},{"title":"Mac常用快捷键和Android+Rn开发环境搭建","slug":"换mac啦","date":"2017-03-21T14:23:28.000Z","updated":"2017-06-04T16:42:27.000Z","comments":true,"path":"换mac啦.html","link":"","permalink":"http://zhanghao.studio/换mac啦.html","excerpt":"一、写在前面的废话 经历一周的纠结，我最终入手了MBP 840。无任何颗粒感的视网膜屏，散发着凉意的金属外壳，象征逼格的信仰灯，真是一件精致的艺术品。敲惯了红轴和茶轴，再体验薄膜键盘也别有一番滋味。我想，我终于理解那些推荐MBP的人了。","text":"一、写在前面的废话 经历一周的纠结，我最终入手了MBP 840。无任何颗粒感的视网膜屏，散发着凉意的金属外壳，象征逼格的信仰灯，真是一件精致的艺术品。敲惯了红轴和茶轴，再体验薄膜键盘也别有一番滋味。我想，我终于理解那些推荐MBP的人了。 二、一些常用快捷键暂时把常用的列举一下，以后再慢慢补充吧。 command + shift + 3/4 截屏/截图 command + m 最小化窗口 command + h 隐藏窗口 command + q 关闭当前程序 command + r 刷新 command + t/w 新建一个选项卡/关闭当前选项卡 command + shift + . 显示隐藏文件夹和文件 command + shift + g 前往指定文件夹 上面是我这几天用的最多的，在知乎上看到一张图，基本上涵盖了最常用的吧： 三、开发环境的搭建 公司项目用的 Android 原生和 React Native混合开发的模式，所以需要搭建 Android 环境和 RN 环境。 Google 了一下，发现苹果有个软件包管理工具 Homebrew 很好用，装上试试 Homebrew是Mac OSX上的软件包管理工具，能在Mac中方便的安装软件或者卸载软件，相当于linux下的apt-get、yum神器；Homebre可以在Mac上安装一些OS X没有的UNIX工具，Homebrew将这些工具统统安装到了 /usr/local/Cellar 目录中，并在 /usr/local/bin 中创建符号链接。 安装很简单，一行指令即可，虽然不懂啥意思… 1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; HomeBrew常用指令 brew search xxx 搜索软件 brew install xxx 安装 brew cask install xxx 安装软件 与上面的区别我不懂，知乎上有两个回答供参考传送门 brew uninstall xxx 卸载 brew list 显示已经安装的软件 我手上这台机器是 os x 10.12.3的，没有自带 Java，所以我们需要手动安装。我们可以去 oracle 官网下载 jdk for mac，也可以用上面提到的 brew cask install java 来进行安装。我没有配置 java 的环境变量，似乎也能用 java -version，神奇。 android studio 直接下载 .dmg 文件即可，它自动设置了 java 的路径， sdk可以通过studio下载,或者找个国内镜像网站下好后放到 sdk 目录下。 ps: 要想在终端下使用 ADB 命令，还得配置sdk的环境变量，参考传送门 进入终端，在用户目录下，输入命令。该命令的作用是如果不存在.bash_profile文件，则创建该文件。 touch .bash_profile 再输入命令，该命令的作用是用文本编辑器TextEdit打开.bash_profile文件 open -e .bash_profile 在编辑器中加入以下路径 export PATH=${PATH}:/Users/xxx(你的sdk路径)/sdk/platform-tools export PATH=${PATH}:/Users/xxx(你的sdk路径)/sdk/tools 保存退出，重启终端，检验是否设置成功 adb version RN 环境搭建，可参考传送门。我简单说下步骤： 安装 node.js ,直接brew install node走你。 安装后，给 npm 设置镜像（GFW你懂得） npm config set registry https://registry.npm.taobao.org --global npm config set disturl https://npm.taobao.org/dist --global 安装 react native 命令行工具 npm install -g react-native-cli 四、终端的 bogon 今晚回家打开终端后，发现终端名称变成了 bogon, what?这他么是啥，搜了一下，找到个解决方案传送门。我用的第一种方法，scutil --set HostName new_hostname ，亲测可行。","categories":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"http://zhanghao.studio/categories/杂七杂八/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://zhanghao.studio/tags/Mac/"}]},{"title":"ARGB与RGBA","slug":"ARGB与RGBA","date":"2017-03-01T14:40:39.000Z","updated":"2017-04-13T14:35:41.000Z","comments":true,"path":"ARGB与RGBA.html","link":"","permalink":"http://zhanghao.studio/ARGB与RGBA.html","excerpt":"一、写在前面的废话今天在rn中调整一个view的backgroudColor时，想设置透明度适中的色值，按照Android原生代码的习惯写成’#77000000’。这种写法在Android项目的xml文件中是没问题的，但是放在js文件的Style中就是不起作用，查了一下，色值有argb和rgba两种格式。","text":"一、写在前面的废话今天在rn中调整一个view的backgroudColor时，想设置透明度适中的色值，按照Android原生代码的习惯写成’#77000000’。这种写法在Android项目的xml文件中是没问题的，但是放在js文件的Style中就是不起作用，查了一下，色值有argb和rgba两种格式。 二、ARGB在Android中颜色值通常遵循RGB/ARGB的标准，以“#”开头，以16进制表示，常用的格式为 1234#RGB#RRGGBB#ARGB#AARRGGBB 上面四个字母都很容易理解，分别是Alpha,Red,Green,Blue。透明度分为256阶（0-255），计算机上用16进制表示为（00-ff）。透明就是0阶，不透明就是255阶,如果50%透明就是127阶。 三、RGBA这四个字母的意思跟上面讲的完全一样，只是透明度放到了最后。粗略的查了一下，RGBA是CSS3标准（这属于前端的知识范畴了，有机会再去学习）新增的，CSS2中色彩模式只有RGB色彩模式和十六进制模式。 我个人理解，这两种格式只是顺序上不同，应用于不同的编程语言中。需要记住，react native中是将表示透明度的两位十六进制数放在最后。","categories":[{"name":"react native","slug":"react-native","permalink":"http://zhanghao.studio/categories/react-native/"}],"tags":[{"name":"react native","slug":"react-native","permalink":"http://zhanghao.studio/tags/react-native/"}]},{"title":"清单文件中activity属性windowSoftInputMode研究","slug":"清单文件中activity属性windowSoftInputMode研究","date":"2017-02-20T16:15:08.000Z","updated":"2017-02-21T16:02:54.000Z","comments":true,"path":"清单文件中activity属性windowSoftInputMode研究.html","link":"","permalink":"http://zhanghao.studio/清单文件中activity属性windowSoftInputMode研究.html","excerpt":"一、写在前面的废话: 今天研究聊天详情页时，发现点击输入框获得焦点后，弹起的软键盘没有盖住EditText,而是将输入框顶了上去。一番搜索，原来是通过在清单文件中给对应activity设置属性windowSoftInputMode做到的。接下来就研究一下这个属性吧。","text":"一、写在前面的废话: 今天研究聊天详情页时，发现点击输入框获得焦点后，弹起的软键盘没有盖住EditText,而是将输入框顶了上去。一番搜索，原来是通过在清单文件中给对应activity设置属性windowSoftInputMode做到的。接下来就研究一下这个属性吧。 二、知识点：​ windowSoftInputMode可以取九个值，分别是： android:windowSoftInputMode=[&quot;stateUnspecified&quot;, &quot;stateUnchanged&quot;, &quot;stateHidden&quot;, &quot;stateAlwaysHidden&quot;, &quot;stateVisible&quot;, &quot;stateAlwaysVisible&quot;, &quot;adjustUnspecified&quot;, &quot;adjustResize&quot;, &quot;adjustPan&quot;] ​ 从命名就可以看出，前六个值跟状态有关，后三个值跟布局的调整有关。关于这两类取值，可以看google官方API给出的解释: The state of the soft keyboard — whether it is hidden or visible — when the activity becomes the focus of user attention.The adjustment made to the activity’s main window — whether it is resized smaller to make room for the soft keyboard or whether its contents pan to make the current focus visible when part of the window is covered by the soft keyboard. ​ 前者是当activity获得用户的焦点时，软键盘是弹出还是隐藏；后者是，当软键盘弹出的时候，当前activity的主窗口是否缩小布局以使软键盘有足够的空间展示，或者使布局里的内容向上滑动以使当前获得焦点的View可见。 The setting must be one of the values listed in the following table, or a combination of one “state...“ value plus one “adjust...“ value. Setting multiple values in either group — multiple “state...“ values, for example — has undefined results. Individual values are separated by a vertical bar (|). For example: ​ 这段话指出，这个属性必须从九个值里取，可以只取一个值，也可以是 state…与adjust的组合，如下： 1&lt;activity android:windowSoftInputMode=\"stateVisible|adjustResize\" . . . &gt; ​ 关于九个值各自的介绍，官方也给出了解释： Value Description stateUnspcified The state of the soft keyboard (whether it is hidden or visible) is not specified. The system will choose an appropriate state or rely on the setting in the theme.This is the default setting for the behavior of the soft keyboard. (这个是默认缺省属性值，显示或者隐藏由系统来确定，或者由当前主题来确定) stateUnchanged The soft keyboard is kept in whatever state it was last in, whether visible or hidden, when the activity comes to the fore.(经测试，似乎没什么卵用。) stateHidden The soft keyboard is hidden when the user chooses the activity — that is, when the user affirmatively navigates forward to the activity, rather than backs into it because of leaving another activity. stateAlwaysHidden The soft keyboard is always hidden when the activity’s main window has input focus. stateVisible The soft keyboard is visible when that’s normally appropriate (when the user is navigating forward to the activity’s main window). stateAlwaysVisible The soft keyboard is made visible when the user chooses the activity — that is, when the user affirmatively navigates forward to the activity, rather than backs into it because of leaving another activity.(设置了这个值或上一个，通过测试发现，进入activity后，软键盘会自动弹起。而设置stateHidden和stateAlwaysHidden则不会。) adjustUnspecified It is unspecified whether the activity’s main window resizes to make room for the soft keyboard, or whether the contents of the window pan to make the current focus visible on-screen. The system will automatically select one of these modes depending on whether the content of the window has any layout views that can scroll their contents. If there is such a view, the window will be resized, on the assumption that scrolling can make all of the window’s contents visible within a smaller area.This is the default setting for the behavior of the main window.(缺省值，到底是缩小布局还是滚动布局中获得焦点控件以上的组件，取决于当前布局中是否有可以滚动的View。) adjustResize The activity’s main window is always resized to make room for the soft keyboard on screen.(触发View的onSizeChanged方法，布局高度缩小了，给软键盘腾出空间。) adjustPan The activity’s main window is not resized to make room for the soft keyboard. Rather, the contents of the window are automatically panned so that the current focus is never obscured by the keyboard and users can always see what they are typing. This is generally less desirable than resizing, because the user may need to close the soft keyboard to get at and interact with obscured parts of the window. ​ 妈蛋的，上面的属性值我挨个试了一遍，但与它给出的结果不一致，我都糊涂了。不过，我发现几个比较靠谱的规律： 用的比较多的是adjustResize和adjustPan，前者是缩小布局得大小，后者是向上移动焦点控件之上的View。 当布局中，焦点组件上方有可滚动的View时，设置为adjustPan，会将当前焦点组件上方的所有View向上移动，以使得焦点组件完全露出，且焦点组件下方的View被软键盘遮盖，这种会导致View被顶出界面；设置为adjustResize，可滚动的View会缩小其高度，给软键盘腾出空间，然后其中焦点组件上方的View会向上滚动，这样可滚动的View上方的View不会滚动，即保持位置不变。 如果焦点组件上方没有可滚动的View，设置为adjustPan，跟上面效果一样；设置为adjustResize，不起作用，焦点组件被盖住了！","categories":[{"name":"android","slug":"android","permalink":"http://zhanghao.studio/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://zhanghao.studio/tags/android/"}]},{"title":"第一篇——利用hexo和github搭建静态博客","slug":"第一篇——利用hexo和github搭建静态博客","date":"2017-02-19T15:52:16.000Z","updated":"2017-04-12T17:37:00.000Z","comments":true,"path":"第一篇——利用hexo和github搭建静态博客.html","link":"","permalink":"http://zhanghao.studio/第一篇——利用hexo和github搭建静态博客.html","excerpt":"最近一周，效率实在不高，某些逻辑我还是一团浆糊。回到家也没有接触别的知识，惭愧不已，这个周日的晚上逼自己将4个月前挖的坑填上，利用hexo和github pages 搭建自己的静态Blog。","text":"最近一周，效率实在不高，某些逻辑我还是一团浆糊。回到家也没有接触别的知识，惭愧不已，这个周日的晚上逼自己将4个月前挖的坑填上，利用hexo和github pages 搭建自己的静态Blog。 教程可以参考这篇文章 传送门 。 坑还没有填满，下次再研究一下： md的语法 添加评论的功能—多说 不蒜子的统计 主题美化 2017–03-26 我来填坑了。 markdown 语法 写了几篇博客，把常用的都记住了，还有一些等以后补充吧。以下都在语法前面加了转义字符”\\”。 # 标题，最多六个，既一级标题到六级标题 [显示的文字](url) 网站的超链接 ![显示的文字](url) 网络图片 > 引用文字 `` 代码 三个` 代码块，后面还可以跟语言名字来显示不同的高亮 - 无序列表 数字 + . + 空格 有序列表 评论 之前看hexo的教程，大多数博主用的社会化评论系统都是多说，但是，多说官方最近宣布即将关闭，传送门，这真是一个悲伤的故事。再查教程，发现正在用的next主题支持多种评论系统，传送门，考虑到稳定性和墙的因素，暂时采用了来必力。配置十分简单，如下： 登陆 来必力 获取你的 LiveRe UID。 编辑 next 主题配置文件， 编辑 livere_uid 字段，设置为 livere_uid: #your livere_uid 不蒜子统计功能 ，照搬官方教程 全局配置 编辑 主题配置文件 中的busuanzi_count的配置项。当enable: true时，代表开启全局开关。若site_uv、site_pv、page_pv的值均为false时，不蒜子仅作记录而不会在页面上显示。 站点UV配置 当site_uv: true时，代表在页面底部显示站点的UV值。 site_uv_header和site_uv_footer为自定义样式配置，相关的值留空时将不显示，可以使用（带特效的）font-awesome。显示效果为[site_uv_header]UV值[site_uv_footer]。 12345&gt; # 效果：本站访客数12345人次&gt; site_uv: true&gt; site_uv_header: 本站访客数&gt; site_uv_footer: 人次&gt; 站点PV配置 当site_pv: true时，代表在页面底部显示站点的PV值。 site_pv_header和site_pv_footer为自定义样式配置，相关的值留空时将不显示，可以使用（带特效的）font-awesome。显示效果为[site_pv_header]PV值[site_pv_footer]。 123456&gt;&gt; # 效果：本站总访问量12345次&gt; site_pv: true&gt; site_pv_header: 本站总访问量&gt; site_pv_footer: 次&gt; 单页面PV配置 当page_pv: true时，代表在文章页面的标题下显示该页面的PV值（阅读数）。 page_pv_header和page_pv_footer为自定义样式配置，相关的值留空时将不显示，可以使用（带特效的）font-awesome。显示效果为[page_pv_header]PV值[page_pv_footer]。 12345&gt; # 效果：本文总阅读量12345次&gt; page_pv: true&gt; page_pv_header: 本文总阅读量&gt; page_pv_footer: 次&gt; 主题美化 之前用的是 yilia，作者的blog。后来发现了更适合我口味的next，文档详细，配置简单，学习成本低，强烈推荐。","categories":[{"name":"hexo","slug":"hexo","permalink":"http://zhanghao.studio/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://zhanghao.studio/tags/hexo/"}]}]}